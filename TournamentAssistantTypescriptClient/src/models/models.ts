// @generated by protobuf-ts 2.8.2
// @generated from protobuf file "models.proto" (package "proto.models", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Channel } from "./discord";
import { Guild } from "./discord";
/**
 * @generated from protobuf message proto.models.Characteristic
 */
export interface Characteristic {
    /**
     * @generated from protobuf field: string serialized_name = 1;
     */
    serializedName: string;
    /**
     * @generated from protobuf field: repeated int32 difficulties = 2;
     */
    difficulties: number[];
}
/**
 * @generated from protobuf message proto.models.Beatmap
 */
export interface Beatmap {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string level_id = 2;
     */
    levelId: string;
    /**
     * @generated from protobuf field: proto.models.Characteristic characteristic = 3;
     */
    characteristic?: Characteristic;
    /**
     * @generated from protobuf field: int32 difficulty = 4;
     */
    difficulty: number;
}
/**
 * @generated from protobuf message proto.models.PreviewBeatmapLevel
 */
export interface PreviewBeatmapLevel {
    /**
     * @generated from protobuf field: string level_id = 1;
     */
    levelId: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: repeated proto.models.Characteristic characteristics = 3;
     */
    characteristics: Characteristic[];
    /**
     * @generated from protobuf field: bool loaded = 4;
     */
    loaded: boolean;
}
/**
 * @generated from protobuf message proto.models.GameplayModifiers
 */
export interface GameplayModifiers {
    /**
     * @generated from protobuf field: proto.models.GameplayModifiers.GameOptions options = 1;
     */
    options: GameplayModifiers_GameOptions;
}
/**
 * @generated from protobuf enum proto.models.GameplayModifiers.GameOptions
 */
export enum GameplayModifiers_GameOptions {
    /**
     * @generated from protobuf enum value: None = 0;
     */
    None = 0,
    /**
     * Negative modifiers
     *
     * @generated from protobuf enum value: NoFail = 1;
     */
    NoFail = 1,
    /**
     * @generated from protobuf enum value: NoBombs = 2;
     */
    NoBombs = 2,
    /**
     * @generated from protobuf enum value: NoArrows = 4;
     */
    NoArrows = 4,
    /**
     * @generated from protobuf enum value: NoObstacles = 8;
     */
    NoObstacles = 8,
    /**
     * @generated from protobuf enum value: SlowSong = 16;
     */
    SlowSong = 16,
    /**
     * Positive Modifiers
     *
     * @generated from protobuf enum value: InstaFail = 32;
     */
    InstaFail = 32,
    /**
     * @generated from protobuf enum value: FailOnClash = 64;
     */
    FailOnClash = 64,
    /**
     * @generated from protobuf enum value: BatteryEnergy = 128;
     */
    BatteryEnergy = 128,
    /**
     * @generated from protobuf enum value: FastNotes = 256;
     */
    FastNotes = 256,
    /**
     * @generated from protobuf enum value: FastSong = 512;
     */
    FastSong = 512,
    /**
     * @generated from protobuf enum value: DisappearingArrows = 1024;
     */
    DisappearingArrows = 1024,
    /**
     * @generated from protobuf enum value: GhostNotes = 2048;
     */
    GhostNotes = 2048,
    /**
     * 1.12.2 Additions
     *
     * @generated from protobuf enum value: DemoNoFail = 4096;
     */
    DemoNoFail = 4096,
    /**
     * @generated from protobuf enum value: DemoNoObstacles = 8192;
     */
    DemoNoObstacles = 8192,
    /**
     * @generated from protobuf enum value: StrictAngles = 16384;
     */
    StrictAngles = 16384,
    /**
     * 1.13.4 Additions
     *
     * @generated from protobuf enum value: ProMode = 32768;
     */
    ProMode = 32768,
    /**
     * @generated from protobuf enum value: ZenMode = 65536;
     */
    ZenMode = 65536,
    /**
     * @generated from protobuf enum value: SmallCubes = 131072;
     */
    SmallCubes = 131072,
    /**
     * @generated from protobuf enum value: SuperFastSong = 262144;
     */
    SuperFastSong = 262144
}
/**
 * @generated from protobuf message proto.models.PlayerSpecificSettings
 */
export interface PlayerSpecificSettings {
    /**
     * @generated from protobuf field: float player_height = 1;
     */
    playerHeight: number;
    /**
     * @generated from protobuf field: float sfx_volume = 2;
     */
    sfxVolume: number;
    /**
     * @generated from protobuf field: float saber_trail_intensity = 3;
     */
    saberTrailIntensity: number;
    /**
     * @generated from protobuf field: float note_jump_start_beat_offset = 4;
     */
    noteJumpStartBeatOffset: number;
    /**
     * @generated from protobuf field: float note_jump_fixed_duration = 5;
     */
    noteJumpFixedDuration: number;
    /**
     * @generated from protobuf field: proto.models.PlayerSpecificSettings.PlayerOptions options = 6;
     */
    options: PlayerSpecificSettings_PlayerOptions;
    /**
     * @generated from protobuf field: proto.models.PlayerSpecificSettings.NoteJumpDurationTypeSettings note_jump_duration_type_settings = 7;
     */
    noteJumpDurationTypeSettings: PlayerSpecificSettings_NoteJumpDurationTypeSettings;
    /**
     * @generated from protobuf field: proto.models.PlayerSpecificSettings.ArcVisibilityType arc_visibility_type = 8;
     */
    arcVisibilityType: PlayerSpecificSettings_ArcVisibilityType;
}
/**
 * @generated from protobuf enum proto.models.PlayerSpecificSettings.PlayerOptions
 */
export enum PlayerSpecificSettings_PlayerOptions {
    /**
     * @generated from protobuf enum value: NoPlayerOptions = 0;
     */
    NoPlayerOptions = 0,
    /**
     * @generated from protobuf enum value: LeftHanded = 1;
     */
    LeftHanded = 1,
    /**
     * @generated from protobuf enum value: StaticLights = 2;
     */
    StaticLights = 2,
    /**
     * @generated from protobuf enum value: NoHud = 4;
     */
    NoHud = 4,
    /**
     * @generated from protobuf enum value: AdvancedHud = 8;
     */
    AdvancedHud = 8,
    /**
     * @generated from protobuf enum value: ReduceDebris = 16;
     */
    ReduceDebris = 16,
    /**
     * @generated from protobuf enum value: AutoPlayerHeight = 32;
     */
    AutoPlayerHeight = 32,
    /**
     * @generated from protobuf enum value: NoFailEffects = 64;
     */
    NoFailEffects = 64,
    /**
     * @generated from protobuf enum value: AutoRestart = 128;
     */
    AutoRestart = 128,
    /**
     * @generated from protobuf enum value: HideNoteSpawnEffect = 256;
     */
    HideNoteSpawnEffect = 256,
    /**
     * @generated from protobuf enum value: AdaptiveSfx = 512;
     */
    AdaptiveSfx = 512,
    /**
     * @generated from protobuf enum value: ArcsHapticFeedback = 1024;
     */
    ArcsHapticFeedback = 1024
}
/**
 * @generated from protobuf enum proto.models.PlayerSpecificSettings.NoteJumpDurationTypeSettings
 */
export enum PlayerSpecificSettings_NoteJumpDurationTypeSettings {
    /**
     * @generated from protobuf enum value: Dynamic = 0;
     */
    Dynamic = 0,
    /**
     * @generated from protobuf enum value: Static = 1;
     */
    Static = 1
}
/**
 * @generated from protobuf enum proto.models.PlayerSpecificSettings.ArcVisibilityType
 */
export enum PlayerSpecificSettings_ArcVisibilityType {
    /**
     * @generated from protobuf enum value: None = 0;
     */
    None = 0,
    /**
     * @generated from protobuf enum value: Low = 1;
     */
    Low = 1,
    /**
     * @generated from protobuf enum value: Standard = 2;
     */
    Standard = 2,
    /**
     * @generated from protobuf enum value: High = 3;
     */
    High = 3
}
/**
 * @generated from protobuf message proto.models.GameplayParameters
 */
export interface GameplayParameters {
    /**
     * @generated from protobuf field: proto.models.Beatmap beatmap = 1;
     */
    beatmap?: Beatmap;
    /**
     * @generated from protobuf field: proto.models.PlayerSpecificSettings player_settings = 2;
     */
    playerSettings?: PlayerSpecificSettings;
    /**
     * @generated from protobuf field: proto.models.GameplayModifiers gameplay_modifiers = 3;
     */
    gameplayModifiers?: GameplayModifiers;
}
/**
 * @generated from protobuf message proto.models.Team
 */
export interface Team {
    /**
     * @generated from protobuf field: string guid = 1;
     */
    guid: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
}
/**
 * @generated from protobuf message proto.models.SongList
 */
export interface SongList {
    /**
     * @generated from protobuf field: repeated proto.models.PreviewBeatmapLevel levels = 1;
     */
    levels: PreviewBeatmapLevel[];
}
/**
 * @generated from protobuf message proto.models.User
 */
export interface User {
    /**
     * @generated from protobuf field: string guid = 1;
     */
    guid: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: string user_id = 3;
     */
    userId: string;
    /**
     * @generated from protobuf field: proto.models.User.ClientTypes client_type = 4;
     */
    clientType: User_ClientTypes;
    /**
     * @generated from protobuf field: proto.models.Team team = 5;
     */
    team?: Team;
    /**
     * @generated from protobuf field: proto.models.User.PlayStates play_state = 6;
     */
    playState: User_PlayStates;
    /**
     * @generated from protobuf field: proto.models.User.DownloadStates download_state = 7;
     */
    downloadState: User_DownloadStates;
    /**
     * @generated from protobuf field: repeated string mod_list = 8;
     */
    modList: string[];
    /**
     * @generated from protobuf field: proto.models.User.Point stream_screen_coordinates = 9;
     */
    streamScreenCoordinates?: User_Point;
    /**
     * @generated from protobuf field: int64 stream_delay_ms = 10;
     */
    streamDelayMs: bigint;
    /**
     * @generated from protobuf field: int64 stream_sync_start_ms = 11;
     */
    streamSyncStartMs: bigint;
    /**
     * @generated from protobuf field: proto.models.User.DiscordInfo discord_info = 12;
     */
    discordInfo?: User_DiscordInfo;
    /**
     * @generated from protobuf field: bytes user_image = 13;
     */
    userImage: Uint8Array;
}
/**
 * @generated from protobuf message proto.models.User.DiscordInfo
 */
export interface User_DiscordInfo {
    /**
     * @generated from protobuf field: string user_id = 1;
     */
    userId: string;
    /**
     * @generated from protobuf field: string username = 2;
     */
    username: string;
    /**
     * @generated from protobuf field: string avatar_url = 3;
     */
    avatarUrl: string;
}
/**
 * @generated from protobuf message proto.models.User.Point
 */
export interface User_Point {
    /**
     * @generated from protobuf field: int32 x = 1;
     */
    x: number;
    /**
     * @generated from protobuf field: int32 y = 2;
     */
    y: number;
}
/**
 * @generated from protobuf enum proto.models.User.PlayStates
 */
export enum User_PlayStates {
    /**
     * @generated from protobuf enum value: Waiting = 0;
     */
    Waiting = 0,
    /**
     * @generated from protobuf enum value: InGame = 1;
     */
    InGame = 1
}
/**
 * @generated from protobuf enum proto.models.User.DownloadStates
 */
export enum User_DownloadStates {
    /**
     * @generated from protobuf enum value: None = 0;
     */
    None = 0,
    /**
     * @generated from protobuf enum value: Downloading = 1;
     */
    Downloading = 1,
    /**
     * @generated from protobuf enum value: Downloaded = 2;
     */
    Downloaded = 2,
    /**
     * @generated from protobuf enum value: DownloadError = 3;
     */
    DownloadError = 3
}
/**
 * @generated from protobuf enum proto.models.User.ClientTypes
 */
export enum User_ClientTypes {
    /**
     * @generated from protobuf enum value: Player = 0;
     */
    Player = 0,
    /**
     * TODO: Is this still used?
     *
     * @generated from protobuf enum value: Coordinator = 1;
     */
    Coordinator = 1,
    /**
     * TODO: Is this still used?
     *
     * @generated from protobuf enum value: TemporaryConnection = 2;
     */
    TemporaryConnection = 2,
    /**
     * @generated from protobuf enum value: WebsocketConnection = 3;
     */
    WebsocketConnection = 3
}
/**
 * @generated from protobuf message proto.models.Match
 */
export interface Match {
    /**
     * @generated from protobuf field: string guid = 1;
     */
    guid: string;
    /**
     * @generated from protobuf field: repeated string associated_users = 2;
     */
    associatedUsers: string[];
    /**
     * @generated from protobuf field: string leader = 3;
     */
    leader: string;
    /**
     * @generated from protobuf field: proto.models.PreviewBeatmapLevel selected_level = 5;
     */
    selectedLevel?: PreviewBeatmapLevel;
    /**
     * @generated from protobuf field: proto.models.Characteristic selected_characteristic = 6;
     */
    selectedCharacteristic?: Characteristic;
    /**
     * @generated from protobuf field: int32 selected_difficulty = 7;
     */
    selectedDifficulty: number;
    /**
     * @generated from protobuf field: string start_time = 8;
     */
    startTime: string;
}
/**
 * @generated from protobuf message proto.models.QualifierEvent
 */
export interface QualifierEvent {
    /**
     * @generated from protobuf field: string guid = 1;
     */
    guid: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: proto.discord.Guild guild = 3;
     */
    guild?: Guild;
    /**
     * @generated from protobuf field: proto.discord.Channel info_channel = 4;
     */
    infoChannel?: Channel;
    /**
     * @generated from protobuf field: repeated proto.models.GameplayParameters qualifier_maps = 5;
     */
    qualifierMaps: GameplayParameters[];
    /**
     * @generated from protobuf field: bool send_scores_to_info_channel = 6;
     */
    sendScoresToInfoChannel: boolean;
    /**
     * @generated from protobuf field: int32 flags = 7;
     */
    flags: number;
}
/**
 * @generated from protobuf enum proto.models.QualifierEvent.EventSettings
 */
export enum QualifierEvent_EventSettings {
    /**
     * @generated from protobuf enum value: None = 0;
     */
    None = 0,
    /**
     * @generated from protobuf enum value: HideScoresFromPlayers = 1;
     */
    HideScoresFromPlayers = 1,
    /**
     * @generated from protobuf enum value: DisableScoresaberSubmission = 2;
     */
    DisableScoresaberSubmission = 2,
    /**
     * @generated from protobuf enum value: EnableLeaderboardMessage = 4;
     */
    EnableLeaderboardMessage = 4
}
/**
 * @generated from protobuf message proto.models.CoreServer
 */
export interface CoreServer {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: string address = 2;
     */
    address: string;
    /**
     * @generated from protobuf field: int32 port = 3;
     */
    port: number;
    /**
     * @generated from protobuf field: int32 websocket_port = 4;
     */
    websocketPort: number;
}
/**
 * @generated from protobuf message proto.models.Tournament
 */
export interface Tournament {
    /**
     * @generated from protobuf field: string guid = 1;
     */
    guid: string;
    /**
     * @generated from protobuf field: proto.models.Tournament.TournamentSettings settings = 2;
     */
    settings?: Tournament_TournamentSettings;
    /**
     * @generated from protobuf field: repeated proto.models.User users = 3;
     */
    users: User[];
    /**
     * @generated from protobuf field: repeated proto.models.Match matches = 4;
     */
    matches: Match[];
    /**
     * @generated from protobuf field: repeated proto.models.QualifierEvent qualifiers = 5;
     */
    qualifiers: QualifierEvent[];
}
/**
 * @generated from protobuf message proto.models.Tournament.TournamentSettings
 */
export interface Tournament_TournamentSettings {
    /**
     * @generated from protobuf field: string tournament_name = 1;
     */
    tournamentName: string;
    /**
     * @generated from protobuf field: bytes tournament_image = 2;
     */
    tournamentImage: Uint8Array;
    /**
     * @generated from protobuf field: bool enable_teams = 3;
     */
    enableTeams: boolean;
    /**
     * @generated from protobuf field: repeated proto.models.Team teams = 4;
     */
    teams: Team[];
    /**
     * @generated from protobuf field: int32 score_update_frequency = 5;
     */
    scoreUpdateFrequency: number;
    /**
     * @generated from protobuf field: repeated string banned_mods = 6;
     */
    bannedMods: string[];
}
/**
 * @generated from protobuf message proto.models.State
 */
export interface State {
    /**
     * @generated from protobuf field: repeated proto.models.Tournament tournaments = 1;
     */
    tournaments: Tournament[];
    /**
     * @generated from protobuf field: repeated proto.models.CoreServer known_servers = 2;
     */
    knownServers: CoreServer[];
}
/**
 * @generated from protobuf message proto.models.ModalOption
 */
export interface ModalOption {
    /**
     * @generated from protobuf field: string label = 1;
     */
    label: string;
    /**
     * @generated from protobuf field: string value = 2;
     */
    value: string;
}
/**
 * @generated from protobuf message proto.models.LeaderboardScore
 */
export interface LeaderboardScore {
    /**
     * @generated from protobuf field: string event_id = 1;
     */
    eventId: string;
    /**
     * @generated from protobuf field: proto.models.GameplayParameters parameters = 2;
     */
    parameters?: GameplayParameters;
    /**
     * @generated from protobuf field: string user_id = 3;
     */
    userId: string;
    /**
     * @generated from protobuf field: string username = 4;
     */
    username: string;
    /**
     * @generated from protobuf field: int32 score = 5;
     */
    score: number;
    /**
     * @generated from protobuf field: bool full_combo = 6;
     */
    fullCombo: boolean;
    /**
     * @generated from protobuf field: string color = 7;
     */
    color: string;
}
/**
 * @generated from protobuf message proto.models.RealtimeScore
 */
export interface RealtimeScore {
    /**
     * @generated from protobuf field: string user_guid = 1;
     */
    userGuid: string;
    /**
     * @generated from protobuf field: int32 score = 2;
     */
    score: number;
    /**
     * @generated from protobuf field: int32 score_with_modifiers = 3;
     */
    scoreWithModifiers: number;
    /**
     * @generated from protobuf field: int32 max_score = 4;
     */
    maxScore: number;
    /**
     * @generated from protobuf field: int32 max_score_with_modifiers = 5;
     */
    maxScoreWithModifiers: number;
    /**
     * @generated from protobuf field: int32 combo = 6;
     */
    combo: number;
    /**
     * @generated from protobuf field: float player_health = 7;
     */
    playerHealth: number;
    /**
     * @generated from protobuf field: float accuracy = 8;
     */
    accuracy: number;
    /**
     * @generated from protobuf field: float song_position = 9;
     */
    songPosition: number;
    /**
     * @generated from protobuf field: int32 notesMissed = 10;
     */
    notesMissed: number;
    /**
     * @generated from protobuf field: int32 badCuts = 11;
     */
    badCuts: number;
    /**
     * @generated from protobuf field: int32 bombHits = 12;
     */
    bombHits: number;
    /**
     * @generated from protobuf field: int32 wallHits = 13;
     */
    wallHits: number;
    /**
     * @generated from protobuf field: int32 maxCombo = 14;
     */
    maxCombo: number;
    /**
     * @generated from protobuf field: proto.models.ScoreTrackerHand leftHand = 15;
     */
    leftHand?: ScoreTrackerHand;
    /**
     * @generated from protobuf field: proto.models.ScoreTrackerHand rightHand = 16;
     */
    rightHand?: ScoreTrackerHand;
}
/**
 * @generated from protobuf message proto.models.ScoreTrackerHand
 */
export interface ScoreTrackerHand {
    /**
     * @generated from protobuf field: int32 hit = 1;
     */
    hit: number;
    /**
     * @generated from protobuf field: int32 miss = 2;
     */
    miss: number;
    /**
     * @generated from protobuf field: int32 badCut = 3;
     */
    badCut: number;
    /**
     * @generated from protobuf field: repeated float avgCut = 4;
     */
    avgCut: number[];
}
// @generated message type with reflection information, may provide speed optimized methods
class Characteristic$Type extends MessageType<Characteristic> {
    constructor() {
        super("proto.models.Characteristic", [
            { no: 1, name: "serialized_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "difficulties", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Characteristic>): Characteristic {
        const message = { serializedName: "", difficulties: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Characteristic>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Characteristic): Characteristic {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string serialized_name */ 1:
                    message.serializedName = reader.string();
                    break;
                case /* repeated int32 difficulties */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.difficulties.push(reader.int32());
                    else
                        message.difficulties.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Characteristic, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string serialized_name = 1; */
        if (message.serializedName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.serializedName);
        /* repeated int32 difficulties = 2; */
        if (message.difficulties.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.difficulties.length; i++)
                writer.int32(message.difficulties[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.models.Characteristic
 */
export const Characteristic = new Characteristic$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Beatmap$Type extends MessageType<Beatmap> {
    constructor() {
        super("proto.models.Beatmap", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "level_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "characteristic", kind: "message", T: () => Characteristic },
            { no: 4, name: "difficulty", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Beatmap>): Beatmap {
        const message = { name: "", levelId: "", difficulty: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Beatmap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Beatmap): Beatmap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string level_id */ 2:
                    message.levelId = reader.string();
                    break;
                case /* proto.models.Characteristic characteristic */ 3:
                    message.characteristic = Characteristic.internalBinaryRead(reader, reader.uint32(), options, message.characteristic);
                    break;
                case /* int32 difficulty */ 4:
                    message.difficulty = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Beatmap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string level_id = 2; */
        if (message.levelId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.levelId);
        /* proto.models.Characteristic characteristic = 3; */
        if (message.characteristic)
            Characteristic.internalBinaryWrite(message.characteristic, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* int32 difficulty = 4; */
        if (message.difficulty !== 0)
            writer.tag(4, WireType.Varint).int32(message.difficulty);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.models.Beatmap
 */
export const Beatmap = new Beatmap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PreviewBeatmapLevel$Type extends MessageType<PreviewBeatmapLevel> {
    constructor() {
        super("proto.models.PreviewBeatmapLevel", [
            { no: 1, name: "level_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "characteristics", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Characteristic },
            { no: 4, name: "loaded", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<PreviewBeatmapLevel>): PreviewBeatmapLevel {
        const message = { levelId: "", name: "", characteristics: [], loaded: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PreviewBeatmapLevel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PreviewBeatmapLevel): PreviewBeatmapLevel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string level_id */ 1:
                    message.levelId = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* repeated proto.models.Characteristic characteristics */ 3:
                    message.characteristics.push(Characteristic.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool loaded */ 4:
                    message.loaded = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PreviewBeatmapLevel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string level_id = 1; */
        if (message.levelId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.levelId);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* repeated proto.models.Characteristic characteristics = 3; */
        for (let i = 0; i < message.characteristics.length; i++)
            Characteristic.internalBinaryWrite(message.characteristics[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool loaded = 4; */
        if (message.loaded !== false)
            writer.tag(4, WireType.Varint).bool(message.loaded);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.models.PreviewBeatmapLevel
 */
export const PreviewBeatmapLevel = new PreviewBeatmapLevel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GameplayModifiers$Type extends MessageType<GameplayModifiers> {
    constructor() {
        super("proto.models.GameplayModifiers", [
            { no: 1, name: "options", kind: "enum", T: () => ["proto.models.GameplayModifiers.GameOptions", GameplayModifiers_GameOptions] }
        ]);
    }
    create(value?: PartialMessage<GameplayModifiers>): GameplayModifiers {
        const message = { options: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GameplayModifiers>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GameplayModifiers): GameplayModifiers {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* proto.models.GameplayModifiers.GameOptions options */ 1:
                    message.options = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GameplayModifiers, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* proto.models.GameplayModifiers.GameOptions options = 1; */
        if (message.options !== 0)
            writer.tag(1, WireType.Varint).int32(message.options);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.models.GameplayModifiers
 */
export const GameplayModifiers = new GameplayModifiers$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerSpecificSettings$Type extends MessageType<PlayerSpecificSettings> {
    constructor() {
        super("proto.models.PlayerSpecificSettings", [
            { no: 1, name: "player_height", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 2, name: "sfx_volume", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "saber_trail_intensity", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "note_jump_start_beat_offset", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "note_jump_fixed_duration", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "options", kind: "enum", T: () => ["proto.models.PlayerSpecificSettings.PlayerOptions", PlayerSpecificSettings_PlayerOptions] },
            { no: 7, name: "note_jump_duration_type_settings", kind: "enum", T: () => ["proto.models.PlayerSpecificSettings.NoteJumpDurationTypeSettings", PlayerSpecificSettings_NoteJumpDurationTypeSettings] },
            { no: 8, name: "arc_visibility_type", kind: "enum", T: () => ["proto.models.PlayerSpecificSettings.ArcVisibilityType", PlayerSpecificSettings_ArcVisibilityType] }
        ]);
    }
    create(value?: PartialMessage<PlayerSpecificSettings>): PlayerSpecificSettings {
        const message = { playerHeight: 0, sfxVolume: 0, saberTrailIntensity: 0, noteJumpStartBeatOffset: 0, noteJumpFixedDuration: 0, options: 0, noteJumpDurationTypeSettings: 0, arcVisibilityType: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlayerSpecificSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerSpecificSettings): PlayerSpecificSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* float player_height */ 1:
                    message.playerHeight = reader.float();
                    break;
                case /* float sfx_volume */ 2:
                    message.sfxVolume = reader.float();
                    break;
                case /* float saber_trail_intensity */ 3:
                    message.saberTrailIntensity = reader.float();
                    break;
                case /* float note_jump_start_beat_offset */ 4:
                    message.noteJumpStartBeatOffset = reader.float();
                    break;
                case /* float note_jump_fixed_duration */ 5:
                    message.noteJumpFixedDuration = reader.float();
                    break;
                case /* proto.models.PlayerSpecificSettings.PlayerOptions options */ 6:
                    message.options = reader.int32();
                    break;
                case /* proto.models.PlayerSpecificSettings.NoteJumpDurationTypeSettings note_jump_duration_type_settings */ 7:
                    message.noteJumpDurationTypeSettings = reader.int32();
                    break;
                case /* proto.models.PlayerSpecificSettings.ArcVisibilityType arc_visibility_type */ 8:
                    message.arcVisibilityType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerSpecificSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* float player_height = 1; */
        if (message.playerHeight !== 0)
            writer.tag(1, WireType.Bit32).float(message.playerHeight);
        /* float sfx_volume = 2; */
        if (message.sfxVolume !== 0)
            writer.tag(2, WireType.Bit32).float(message.sfxVolume);
        /* float saber_trail_intensity = 3; */
        if (message.saberTrailIntensity !== 0)
            writer.tag(3, WireType.Bit32).float(message.saberTrailIntensity);
        /* float note_jump_start_beat_offset = 4; */
        if (message.noteJumpStartBeatOffset !== 0)
            writer.tag(4, WireType.Bit32).float(message.noteJumpStartBeatOffset);
        /* float note_jump_fixed_duration = 5; */
        if (message.noteJumpFixedDuration !== 0)
            writer.tag(5, WireType.Bit32).float(message.noteJumpFixedDuration);
        /* proto.models.PlayerSpecificSettings.PlayerOptions options = 6; */
        if (message.options !== 0)
            writer.tag(6, WireType.Varint).int32(message.options);
        /* proto.models.PlayerSpecificSettings.NoteJumpDurationTypeSettings note_jump_duration_type_settings = 7; */
        if (message.noteJumpDurationTypeSettings !== 0)
            writer.tag(7, WireType.Varint).int32(message.noteJumpDurationTypeSettings);
        /* proto.models.PlayerSpecificSettings.ArcVisibilityType arc_visibility_type = 8; */
        if (message.arcVisibilityType !== 0)
            writer.tag(8, WireType.Varint).int32(message.arcVisibilityType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.models.PlayerSpecificSettings
 */
export const PlayerSpecificSettings = new PlayerSpecificSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GameplayParameters$Type extends MessageType<GameplayParameters> {
    constructor() {
        super("proto.models.GameplayParameters", [
            { no: 1, name: "beatmap", kind: "message", T: () => Beatmap },
            { no: 2, name: "player_settings", kind: "message", T: () => PlayerSpecificSettings },
            { no: 3, name: "gameplay_modifiers", kind: "message", T: () => GameplayModifiers }
        ]);
    }
    create(value?: PartialMessage<GameplayParameters>): GameplayParameters {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GameplayParameters>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GameplayParameters): GameplayParameters {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* proto.models.Beatmap beatmap */ 1:
                    message.beatmap = Beatmap.internalBinaryRead(reader, reader.uint32(), options, message.beatmap);
                    break;
                case /* proto.models.PlayerSpecificSettings player_settings */ 2:
                    message.playerSettings = PlayerSpecificSettings.internalBinaryRead(reader, reader.uint32(), options, message.playerSettings);
                    break;
                case /* proto.models.GameplayModifiers gameplay_modifiers */ 3:
                    message.gameplayModifiers = GameplayModifiers.internalBinaryRead(reader, reader.uint32(), options, message.gameplayModifiers);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GameplayParameters, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* proto.models.Beatmap beatmap = 1; */
        if (message.beatmap)
            Beatmap.internalBinaryWrite(message.beatmap, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* proto.models.PlayerSpecificSettings player_settings = 2; */
        if (message.playerSettings)
            PlayerSpecificSettings.internalBinaryWrite(message.playerSettings, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* proto.models.GameplayModifiers gameplay_modifiers = 3; */
        if (message.gameplayModifiers)
            GameplayModifiers.internalBinaryWrite(message.gameplayModifiers, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.models.GameplayParameters
 */
export const GameplayParameters = new GameplayParameters$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Team$Type extends MessageType<Team> {
    constructor() {
        super("proto.models.Team", [
            { no: 1, name: "guid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Team>): Team {
        const message = { guid: "", name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Team>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Team): Team {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string guid */ 1:
                    message.guid = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Team, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string guid = 1; */
        if (message.guid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.guid);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.models.Team
 */
export const Team = new Team$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SongList$Type extends MessageType<SongList> {
    constructor() {
        super("proto.models.SongList", [
            { no: 1, name: "levels", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PreviewBeatmapLevel }
        ]);
    }
    create(value?: PartialMessage<SongList>): SongList {
        const message = { levels: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SongList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SongList): SongList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated proto.models.PreviewBeatmapLevel levels */ 1:
                    message.levels.push(PreviewBeatmapLevel.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SongList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated proto.models.PreviewBeatmapLevel levels = 1; */
        for (let i = 0; i < message.levels.length; i++)
            PreviewBeatmapLevel.internalBinaryWrite(message.levels[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.models.SongList
 */
export const SongList = new SongList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class User$Type extends MessageType<User> {
    constructor() {
        super("proto.models.User", [
            { no: 1, name: "guid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "client_type", kind: "enum", T: () => ["proto.models.User.ClientTypes", User_ClientTypes] },
            { no: 5, name: "team", kind: "message", T: () => Team },
            { no: 6, name: "play_state", kind: "enum", T: () => ["proto.models.User.PlayStates", User_PlayStates] },
            { no: 7, name: "download_state", kind: "enum", T: () => ["proto.models.User.DownloadStates", User_DownloadStates] },
            { no: 8, name: "mod_list", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "stream_screen_coordinates", kind: "message", T: () => User_Point },
            { no: 10, name: "stream_delay_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "stream_sync_start_ms", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "discord_info", kind: "message", T: () => User_DiscordInfo },
            { no: 13, name: "user_image", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<User>): User {
        const message = { guid: "", name: "", userId: "", clientType: 0, playState: 0, downloadState: 0, modList: [], streamDelayMs: 0n, streamSyncStartMs: 0n, userImage: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<User>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: User): User {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string guid */ 1:
                    message.guid = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string user_id */ 3:
                    message.userId = reader.string();
                    break;
                case /* proto.models.User.ClientTypes client_type */ 4:
                    message.clientType = reader.int32();
                    break;
                case /* proto.models.Team team */ 5:
                    message.team = Team.internalBinaryRead(reader, reader.uint32(), options, message.team);
                    break;
                case /* proto.models.User.PlayStates play_state */ 6:
                    message.playState = reader.int32();
                    break;
                case /* proto.models.User.DownloadStates download_state */ 7:
                    message.downloadState = reader.int32();
                    break;
                case /* repeated string mod_list */ 8:
                    message.modList.push(reader.string());
                    break;
                case /* proto.models.User.Point stream_screen_coordinates */ 9:
                    message.streamScreenCoordinates = User_Point.internalBinaryRead(reader, reader.uint32(), options, message.streamScreenCoordinates);
                    break;
                case /* int64 stream_delay_ms */ 10:
                    message.streamDelayMs = reader.int64().toBigInt();
                    break;
                case /* int64 stream_sync_start_ms */ 11:
                    message.streamSyncStartMs = reader.int64().toBigInt();
                    break;
                case /* proto.models.User.DiscordInfo discord_info */ 12:
                    message.discordInfo = User_DiscordInfo.internalBinaryRead(reader, reader.uint32(), options, message.discordInfo);
                    break;
                case /* bytes user_image */ 13:
                    message.userImage = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: User, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string guid = 1; */
        if (message.guid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.guid);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string user_id = 3; */
        if (message.userId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.userId);
        /* proto.models.User.ClientTypes client_type = 4; */
        if (message.clientType !== 0)
            writer.tag(4, WireType.Varint).int32(message.clientType);
        /* proto.models.Team team = 5; */
        if (message.team)
            Team.internalBinaryWrite(message.team, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* proto.models.User.PlayStates play_state = 6; */
        if (message.playState !== 0)
            writer.tag(6, WireType.Varint).int32(message.playState);
        /* proto.models.User.DownloadStates download_state = 7; */
        if (message.downloadState !== 0)
            writer.tag(7, WireType.Varint).int32(message.downloadState);
        /* repeated string mod_list = 8; */
        for (let i = 0; i < message.modList.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.modList[i]);
        /* proto.models.User.Point stream_screen_coordinates = 9; */
        if (message.streamScreenCoordinates)
            User_Point.internalBinaryWrite(message.streamScreenCoordinates, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* int64 stream_delay_ms = 10; */
        if (message.streamDelayMs !== 0n)
            writer.tag(10, WireType.Varint).int64(message.streamDelayMs);
        /* int64 stream_sync_start_ms = 11; */
        if (message.streamSyncStartMs !== 0n)
            writer.tag(11, WireType.Varint).int64(message.streamSyncStartMs);
        /* proto.models.User.DiscordInfo discord_info = 12; */
        if (message.discordInfo)
            User_DiscordInfo.internalBinaryWrite(message.discordInfo, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* bytes user_image = 13; */
        if (message.userImage.length)
            writer.tag(13, WireType.LengthDelimited).bytes(message.userImage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.models.User
 */
export const User = new User$Type();
// @generated message type with reflection information, may provide speed optimized methods
class User_DiscordInfo$Type extends MessageType<User_DiscordInfo> {
    constructor() {
        super("proto.models.User.DiscordInfo", [
            { no: 1, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "avatar_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<User_DiscordInfo>): User_DiscordInfo {
        const message = { userId: "", username: "", avatarUrl: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<User_DiscordInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: User_DiscordInfo): User_DiscordInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 1:
                    message.userId = reader.string();
                    break;
                case /* string username */ 2:
                    message.username = reader.string();
                    break;
                case /* string avatar_url */ 3:
                    message.avatarUrl = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: User_DiscordInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        /* string username = 2; */
        if (message.username !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.username);
        /* string avatar_url = 3; */
        if (message.avatarUrl !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.avatarUrl);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.models.User.DiscordInfo
 */
export const User_DiscordInfo = new User_DiscordInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class User_Point$Type extends MessageType<User_Point> {
    constructor() {
        super("proto.models.User.Point", [
            { no: 1, name: "x", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "y", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<User_Point>): User_Point {
        const message = { x: 0, y: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<User_Point>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: User_Point): User_Point {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 x */ 1:
                    message.x = reader.int32();
                    break;
                case /* int32 y */ 2:
                    message.y = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: User_Point, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 x = 1; */
        if (message.x !== 0)
            writer.tag(1, WireType.Varint).int32(message.x);
        /* int32 y = 2; */
        if (message.y !== 0)
            writer.tag(2, WireType.Varint).int32(message.y);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.models.User.Point
 */
export const User_Point = new User_Point$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Match$Type extends MessageType<Match> {
    constructor() {
        super("proto.models.Match", [
            { no: 1, name: "guid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "associated_users", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "leader", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "selected_level", kind: "message", T: () => PreviewBeatmapLevel },
            { no: 6, name: "selected_characteristic", kind: "message", T: () => Characteristic },
            { no: 7, name: "selected_difficulty", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "start_time", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Match>): Match {
        const message = { guid: "", associatedUsers: [], leader: "", selectedDifficulty: 0, startTime: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Match>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Match): Match {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string guid */ 1:
                    message.guid = reader.string();
                    break;
                case /* repeated string associated_users */ 2:
                    message.associatedUsers.push(reader.string());
                    break;
                case /* string leader */ 3:
                    message.leader = reader.string();
                    break;
                case /* proto.models.PreviewBeatmapLevel selected_level */ 5:
                    message.selectedLevel = PreviewBeatmapLevel.internalBinaryRead(reader, reader.uint32(), options, message.selectedLevel);
                    break;
                case /* proto.models.Characteristic selected_characteristic */ 6:
                    message.selectedCharacteristic = Characteristic.internalBinaryRead(reader, reader.uint32(), options, message.selectedCharacteristic);
                    break;
                case /* int32 selected_difficulty */ 7:
                    message.selectedDifficulty = reader.int32();
                    break;
                case /* string start_time */ 8:
                    message.startTime = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Match, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string guid = 1; */
        if (message.guid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.guid);
        /* repeated string associated_users = 2; */
        for (let i = 0; i < message.associatedUsers.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.associatedUsers[i]);
        /* string leader = 3; */
        if (message.leader !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.leader);
        /* proto.models.PreviewBeatmapLevel selected_level = 5; */
        if (message.selectedLevel)
            PreviewBeatmapLevel.internalBinaryWrite(message.selectedLevel, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* proto.models.Characteristic selected_characteristic = 6; */
        if (message.selectedCharacteristic)
            Characteristic.internalBinaryWrite(message.selectedCharacteristic, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* int32 selected_difficulty = 7; */
        if (message.selectedDifficulty !== 0)
            writer.tag(7, WireType.Varint).int32(message.selectedDifficulty);
        /* string start_time = 8; */
        if (message.startTime !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.startTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.models.Match
 */
export const Match = new Match$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QualifierEvent$Type extends MessageType<QualifierEvent> {
    constructor() {
        super("proto.models.QualifierEvent", [
            { no: 1, name: "guid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "guild", kind: "message", T: () => Guild },
            { no: 4, name: "info_channel", kind: "message", T: () => Channel },
            { no: 5, name: "qualifier_maps", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GameplayParameters },
            { no: 6, name: "send_scores_to_info_channel", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "flags", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<QualifierEvent>): QualifierEvent {
        const message = { guid: "", name: "", qualifierMaps: [], sendScoresToInfoChannel: false, flags: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QualifierEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QualifierEvent): QualifierEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string guid */ 1:
                    message.guid = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* proto.discord.Guild guild */ 3:
                    message.guild = Guild.internalBinaryRead(reader, reader.uint32(), options, message.guild);
                    break;
                case /* proto.discord.Channel info_channel */ 4:
                    message.infoChannel = Channel.internalBinaryRead(reader, reader.uint32(), options, message.infoChannel);
                    break;
                case /* repeated proto.models.GameplayParameters qualifier_maps */ 5:
                    message.qualifierMaps.push(GameplayParameters.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool send_scores_to_info_channel */ 6:
                    message.sendScoresToInfoChannel = reader.bool();
                    break;
                case /* int32 flags */ 7:
                    message.flags = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QualifierEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string guid = 1; */
        if (message.guid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.guid);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* proto.discord.Guild guild = 3; */
        if (message.guild)
            Guild.internalBinaryWrite(message.guild, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* proto.discord.Channel info_channel = 4; */
        if (message.infoChannel)
            Channel.internalBinaryWrite(message.infoChannel, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated proto.models.GameplayParameters qualifier_maps = 5; */
        for (let i = 0; i < message.qualifierMaps.length; i++)
            GameplayParameters.internalBinaryWrite(message.qualifierMaps[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* bool send_scores_to_info_channel = 6; */
        if (message.sendScoresToInfoChannel !== false)
            writer.tag(6, WireType.Varint).bool(message.sendScoresToInfoChannel);
        /* int32 flags = 7; */
        if (message.flags !== 0)
            writer.tag(7, WireType.Varint).int32(message.flags);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.models.QualifierEvent
 */
export const QualifierEvent = new QualifierEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CoreServer$Type extends MessageType<CoreServer> {
    constructor() {
        super("proto.models.CoreServer", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "port", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "websocket_port", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CoreServer>): CoreServer {
        const message = { name: "", address: "", port: 0, websocketPort: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CoreServer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CoreServer): CoreServer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string address */ 2:
                    message.address = reader.string();
                    break;
                case /* int32 port */ 3:
                    message.port = reader.int32();
                    break;
                case /* int32 websocket_port */ 4:
                    message.websocketPort = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CoreServer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string address = 2; */
        if (message.address !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.address);
        /* int32 port = 3; */
        if (message.port !== 0)
            writer.tag(3, WireType.Varint).int32(message.port);
        /* int32 websocket_port = 4; */
        if (message.websocketPort !== 0)
            writer.tag(4, WireType.Varint).int32(message.websocketPort);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.models.CoreServer
 */
export const CoreServer = new CoreServer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Tournament$Type extends MessageType<Tournament> {
    constructor() {
        super("proto.models.Tournament", [
            { no: 1, name: "guid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "settings", kind: "message", T: () => Tournament_TournamentSettings },
            { no: 3, name: "users", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => User },
            { no: 4, name: "matches", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Match },
            { no: 5, name: "qualifiers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => QualifierEvent }
        ]);
    }
    create(value?: PartialMessage<Tournament>): Tournament {
        const message = { guid: "", users: [], matches: [], qualifiers: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Tournament>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Tournament): Tournament {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string guid */ 1:
                    message.guid = reader.string();
                    break;
                case /* proto.models.Tournament.TournamentSettings settings */ 2:
                    message.settings = Tournament_TournamentSettings.internalBinaryRead(reader, reader.uint32(), options, message.settings);
                    break;
                case /* repeated proto.models.User users */ 3:
                    message.users.push(User.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated proto.models.Match matches */ 4:
                    message.matches.push(Match.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated proto.models.QualifierEvent qualifiers */ 5:
                    message.qualifiers.push(QualifierEvent.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Tournament, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string guid = 1; */
        if (message.guid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.guid);
        /* proto.models.Tournament.TournamentSettings settings = 2; */
        if (message.settings)
            Tournament_TournamentSettings.internalBinaryWrite(message.settings, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated proto.models.User users = 3; */
        for (let i = 0; i < message.users.length; i++)
            User.internalBinaryWrite(message.users[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated proto.models.Match matches = 4; */
        for (let i = 0; i < message.matches.length; i++)
            Match.internalBinaryWrite(message.matches[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated proto.models.QualifierEvent qualifiers = 5; */
        for (let i = 0; i < message.qualifiers.length; i++)
            QualifierEvent.internalBinaryWrite(message.qualifiers[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.models.Tournament
 */
export const Tournament = new Tournament$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Tournament_TournamentSettings$Type extends MessageType<Tournament_TournamentSettings> {
    constructor() {
        super("proto.models.Tournament.TournamentSettings", [
            { no: 1, name: "tournament_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "tournament_image", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "enable_teams", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "teams", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Team },
            { no: 5, name: "score_update_frequency", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "banned_mods", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Tournament_TournamentSettings>): Tournament_TournamentSettings {
        const message = { tournamentName: "", tournamentImage: new Uint8Array(0), enableTeams: false, teams: [], scoreUpdateFrequency: 0, bannedMods: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Tournament_TournamentSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Tournament_TournamentSettings): Tournament_TournamentSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tournament_name */ 1:
                    message.tournamentName = reader.string();
                    break;
                case /* bytes tournament_image */ 2:
                    message.tournamentImage = reader.bytes();
                    break;
                case /* bool enable_teams */ 3:
                    message.enableTeams = reader.bool();
                    break;
                case /* repeated proto.models.Team teams */ 4:
                    message.teams.push(Team.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 score_update_frequency */ 5:
                    message.scoreUpdateFrequency = reader.int32();
                    break;
                case /* repeated string banned_mods */ 6:
                    message.bannedMods.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Tournament_TournamentSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tournament_name = 1; */
        if (message.tournamentName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tournamentName);
        /* bytes tournament_image = 2; */
        if (message.tournamentImage.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.tournamentImage);
        /* bool enable_teams = 3; */
        if (message.enableTeams !== false)
            writer.tag(3, WireType.Varint).bool(message.enableTeams);
        /* repeated proto.models.Team teams = 4; */
        for (let i = 0; i < message.teams.length; i++)
            Team.internalBinaryWrite(message.teams[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* int32 score_update_frequency = 5; */
        if (message.scoreUpdateFrequency !== 0)
            writer.tag(5, WireType.Varint).int32(message.scoreUpdateFrequency);
        /* repeated string banned_mods = 6; */
        for (let i = 0; i < message.bannedMods.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.bannedMods[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.models.Tournament.TournamentSettings
 */
export const Tournament_TournamentSettings = new Tournament_TournamentSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class State$Type extends MessageType<State> {
    constructor() {
        super("proto.models.State", [
            { no: 1, name: "tournaments", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Tournament },
            { no: 2, name: "known_servers", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => CoreServer }
        ]);
    }
    create(value?: PartialMessage<State>): State {
        const message = { tournaments: [], knownServers: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<State>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: State): State {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated proto.models.Tournament tournaments */ 1:
                    message.tournaments.push(Tournament.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated proto.models.CoreServer known_servers */ 2:
                    message.knownServers.push(CoreServer.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: State, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated proto.models.Tournament tournaments = 1; */
        for (let i = 0; i < message.tournaments.length; i++)
            Tournament.internalBinaryWrite(message.tournaments[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated proto.models.CoreServer known_servers = 2; */
        for (let i = 0; i < message.knownServers.length; i++)
            CoreServer.internalBinaryWrite(message.knownServers[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.models.State
 */
export const State = new State$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ModalOption$Type extends MessageType<ModalOption> {
    constructor() {
        super("proto.models.ModalOption", [
            { no: 1, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ModalOption>): ModalOption {
        const message = { label: "", value: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ModalOption>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ModalOption): ModalOption {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string label */ 1:
                    message.label = reader.string();
                    break;
                case /* string value */ 2:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ModalOption, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string label = 1; */
        if (message.label !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.label);
        /* string value = 2; */
        if (message.value !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.models.ModalOption
 */
export const ModalOption = new ModalOption$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LeaderboardScore$Type extends MessageType<LeaderboardScore> {
    constructor() {
        super("proto.models.LeaderboardScore", [
            { no: 1, name: "event_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "parameters", kind: "message", T: () => GameplayParameters },
            { no: 3, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "score", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "full_combo", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "color", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LeaderboardScore>): LeaderboardScore {
        const message = { eventId: "", userId: "", username: "", score: 0, fullCombo: false, color: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LeaderboardScore>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LeaderboardScore): LeaderboardScore {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string event_id */ 1:
                    message.eventId = reader.string();
                    break;
                case /* proto.models.GameplayParameters parameters */ 2:
                    message.parameters = GameplayParameters.internalBinaryRead(reader, reader.uint32(), options, message.parameters);
                    break;
                case /* string user_id */ 3:
                    message.userId = reader.string();
                    break;
                case /* string username */ 4:
                    message.username = reader.string();
                    break;
                case /* int32 score */ 5:
                    message.score = reader.int32();
                    break;
                case /* bool full_combo */ 6:
                    message.fullCombo = reader.bool();
                    break;
                case /* string color */ 7:
                    message.color = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LeaderboardScore, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string event_id = 1; */
        if (message.eventId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.eventId);
        /* proto.models.GameplayParameters parameters = 2; */
        if (message.parameters)
            GameplayParameters.internalBinaryWrite(message.parameters, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string user_id = 3; */
        if (message.userId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.userId);
        /* string username = 4; */
        if (message.username !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.username);
        /* int32 score = 5; */
        if (message.score !== 0)
            writer.tag(5, WireType.Varint).int32(message.score);
        /* bool full_combo = 6; */
        if (message.fullCombo !== false)
            writer.tag(6, WireType.Varint).bool(message.fullCombo);
        /* string color = 7; */
        if (message.color !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.color);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.models.LeaderboardScore
 */
export const LeaderboardScore = new LeaderboardScore$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RealtimeScore$Type extends MessageType<RealtimeScore> {
    constructor() {
        super("proto.models.RealtimeScore", [
            { no: 1, name: "user_guid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "score", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "score_with_modifiers", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "max_score", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "max_score_with_modifiers", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "combo", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "player_health", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "accuracy", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 9, name: "song_position", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 10, name: "notesMissed", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "badCuts", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "bombHits", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "wallHits", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "maxCombo", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 15, name: "leftHand", kind: "message", T: () => ScoreTrackerHand },
            { no: 16, name: "rightHand", kind: "message", T: () => ScoreTrackerHand }
        ]);
    }
    create(value?: PartialMessage<RealtimeScore>): RealtimeScore {
        const message = { userGuid: "", score: 0, scoreWithModifiers: 0, maxScore: 0, maxScoreWithModifiers: 0, combo: 0, playerHealth: 0, accuracy: 0, songPosition: 0, notesMissed: 0, badCuts: 0, bombHits: 0, wallHits: 0, maxCombo: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RealtimeScore>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RealtimeScore): RealtimeScore {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_guid */ 1:
                    message.userGuid = reader.string();
                    break;
                case /* int32 score */ 2:
                    message.score = reader.int32();
                    break;
                case /* int32 score_with_modifiers */ 3:
                    message.scoreWithModifiers = reader.int32();
                    break;
                case /* int32 max_score */ 4:
                    message.maxScore = reader.int32();
                    break;
                case /* int32 max_score_with_modifiers */ 5:
                    message.maxScoreWithModifiers = reader.int32();
                    break;
                case /* int32 combo */ 6:
                    message.combo = reader.int32();
                    break;
                case /* float player_health */ 7:
                    message.playerHealth = reader.float();
                    break;
                case /* float accuracy */ 8:
                    message.accuracy = reader.float();
                    break;
                case /* float song_position */ 9:
                    message.songPosition = reader.float();
                    break;
                case /* int32 notesMissed */ 10:
                    message.notesMissed = reader.int32();
                    break;
                case /* int32 badCuts */ 11:
                    message.badCuts = reader.int32();
                    break;
                case /* int32 bombHits */ 12:
                    message.bombHits = reader.int32();
                    break;
                case /* int32 wallHits */ 13:
                    message.wallHits = reader.int32();
                    break;
                case /* int32 maxCombo */ 14:
                    message.maxCombo = reader.int32();
                    break;
                case /* proto.models.ScoreTrackerHand leftHand */ 15:
                    message.leftHand = ScoreTrackerHand.internalBinaryRead(reader, reader.uint32(), options, message.leftHand);
                    break;
                case /* proto.models.ScoreTrackerHand rightHand */ 16:
                    message.rightHand = ScoreTrackerHand.internalBinaryRead(reader, reader.uint32(), options, message.rightHand);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RealtimeScore, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_guid = 1; */
        if (message.userGuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userGuid);
        /* int32 score = 2; */
        if (message.score !== 0)
            writer.tag(2, WireType.Varint).int32(message.score);
        /* int32 score_with_modifiers = 3; */
        if (message.scoreWithModifiers !== 0)
            writer.tag(3, WireType.Varint).int32(message.scoreWithModifiers);
        /* int32 max_score = 4; */
        if (message.maxScore !== 0)
            writer.tag(4, WireType.Varint).int32(message.maxScore);
        /* int32 max_score_with_modifiers = 5; */
        if (message.maxScoreWithModifiers !== 0)
            writer.tag(5, WireType.Varint).int32(message.maxScoreWithModifiers);
        /* int32 combo = 6; */
        if (message.combo !== 0)
            writer.tag(6, WireType.Varint).int32(message.combo);
        /* float player_health = 7; */
        if (message.playerHealth !== 0)
            writer.tag(7, WireType.Bit32).float(message.playerHealth);
        /* float accuracy = 8; */
        if (message.accuracy !== 0)
            writer.tag(8, WireType.Bit32).float(message.accuracy);
        /* float song_position = 9; */
        if (message.songPosition !== 0)
            writer.tag(9, WireType.Bit32).float(message.songPosition);
        /* int32 notesMissed = 10; */
        if (message.notesMissed !== 0)
            writer.tag(10, WireType.Varint).int32(message.notesMissed);
        /* int32 badCuts = 11; */
        if (message.badCuts !== 0)
            writer.tag(11, WireType.Varint).int32(message.badCuts);
        /* int32 bombHits = 12; */
        if (message.bombHits !== 0)
            writer.tag(12, WireType.Varint).int32(message.bombHits);
        /* int32 wallHits = 13; */
        if (message.wallHits !== 0)
            writer.tag(13, WireType.Varint).int32(message.wallHits);
        /* int32 maxCombo = 14; */
        if (message.maxCombo !== 0)
            writer.tag(14, WireType.Varint).int32(message.maxCombo);
        /* proto.models.ScoreTrackerHand leftHand = 15; */
        if (message.leftHand)
            ScoreTrackerHand.internalBinaryWrite(message.leftHand, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* proto.models.ScoreTrackerHand rightHand = 16; */
        if (message.rightHand)
            ScoreTrackerHand.internalBinaryWrite(message.rightHand, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.models.RealtimeScore
 */
export const RealtimeScore = new RealtimeScore$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScoreTrackerHand$Type extends MessageType<ScoreTrackerHand> {
    constructor() {
        super("proto.models.ScoreTrackerHand", [
            { no: 1, name: "hit", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "miss", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "badCut", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "avgCut", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<ScoreTrackerHand>): ScoreTrackerHand {
        const message = { hit: 0, miss: 0, badCut: 0, avgCut: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ScoreTrackerHand>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScoreTrackerHand): ScoreTrackerHand {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 hit */ 1:
                    message.hit = reader.int32();
                    break;
                case /* int32 miss */ 2:
                    message.miss = reader.int32();
                    break;
                case /* int32 badCut */ 3:
                    message.badCut = reader.int32();
                    break;
                case /* repeated float avgCut */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.avgCut.push(reader.float());
                    else
                        message.avgCut.push(reader.float());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScoreTrackerHand, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 hit = 1; */
        if (message.hit !== 0)
            writer.tag(1, WireType.Varint).int32(message.hit);
        /* int32 miss = 2; */
        if (message.miss !== 0)
            writer.tag(2, WireType.Varint).int32(message.miss);
        /* int32 badCut = 3; */
        if (message.badCut !== 0)
            writer.tag(3, WireType.Varint).int32(message.badCut);
        /* repeated float avgCut = 4; */
        if (message.avgCut.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.avgCut.length; i++)
                writer.float(message.avgCut[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message proto.models.ScoreTrackerHand
 */
export const ScoreTrackerHand = new ScoreTrackerHand$Type();
